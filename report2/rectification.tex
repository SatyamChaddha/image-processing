% vim:ft=tex
% rubber: module xelatex
\subsection{Rectification}
\label{sec:rectification}

We have implemented image rectification based on the previous calibration work.
That is, we use the intrinsic and extrinsic parameters from the calibration to
calculate the perspective transformation required to rectify the images. More
specifically, we get the following values from the calibration:

\begin{itemize}
\item $T_l,T_r$, the translation vectors from the calibration object to the left
  resp right camera origin, in the camera reference frames.

\item $R_l,R_r$, rotation matrices from the calibration object reference system to
  the left resp right camera reference systems.

\item $f_l, f_r$, the focal lengths.
\end{itemize}

From these the following values are computed:

\begin{itemize}
\item $R=R_lR_r^{-1}$, the rotation matrix from the right to the left reference
  frame.

\item $T=RT_r-T_l$, the translation vector from the left to the right camera
  origin, in the left camera reference.

\item $R_{rect}$, the rectification rotation matrix. This is computed by
  creating an orthonormal base where $X$ is the $T$ vector, $Y$ is the cross
  product of the unit vector in the $Z$ axis direction with $X$, and $Z$ is the
  cross product of $X$ and $Y$ (all normalised to unit length).

\item $f$ the average of the left and right focal lengths.
\end{itemize}

From these values, the rectification is computed so that the left image is
rectified by $R_{rect}$ and the right image is rectified b $RR_{rect}$. The
rectification coordinates are computed in 3D space, by turning the pixel
coordinates into three-dimensional coordinates (offset so that (0,0) is the
middle of the image), with the $z$ component being the focal length, and then
applying the rectification matrices. The values are then multiplied by $f/z$, so
that the new values are again at focal length $z$ values. The OpenCV
\texttt{remap()} function is used to do the actual remapping of pixels and
interpolating non-existent pixels (bicubic interpolation in a 4x4 neighbourhood
is used).

\subsubsection{Testing rectification accuracy}
We have tested the accuracy of the rectification by rectifying test images with
a chessboard pattern on them and using OpenCV's algorithm for extracting the
grid corners of the chessboard from the rectified images and comparing their y
coordinate positions. If the rectification is accurate, all the corners should
have the same y coordinates, so the actual disparities can be used as a measure
of rectification error.

The mean errors for the six images we tested are listed in
table~\ref{tab:rectification-error}. Each image has 80 interior corners in the
chessboards, and the image mean values are for all these corners. The overall
mean and standard deviation are also given, as the mean for all six images (i.e.
480 corners). Overall, the results show that the accuracy leaves something to be
desired, but is not completely unreasonable. Our initial experiments showed that
the quality of the calibration data has a large impact on the accuracy of the
rectification; the errors given here is for the best calibration data we were
able to obtain from the test images.

\begin{table}[h]
  \centering
  \begin{tabular}{c c c}
    \toprule
    Image & Mean error & Std dev \\
    \midrule
    DSCF4060 & 3.57  & 1.70 \\
    DSCF4061 & 3.68  & 1.60 \\
    DSCF4062 & 7.01  & 1.67 \\
    DSCF4063 & 4.40  & 1.81 \\
    DSCF4065 & 7.75  & 1.41 \\
    DSCF4066 & 7.16  & 1.84 \\
    \midrule
    Average  & 5.60  & 1.67 \\
    \bottomrule
  \end{tabular}
  \caption[Rectification errors]{Rectification errors. The mean error and
    standard deviation for the vertical displacement between the same points
    between the left and right images (for 80 chessboard grid corners).}
  \label{tab:rectification-error}
\end{table}

