% vim:ft=tex
% rubber: module xelatex

\subsection{Stereo matching}
\label{sec:stereo}

We followed the methods described in \cite{realtimestereo} to implement dynamic programming for stereo matching.

In the simplest case, we do all of the following for each scanline of the image pair in turn.

Step 1: initialise disparity maps DisparityMapL and DisparityMapR.

Step 2: create a dynamic programming matrix A, whose dimensionality is equal to the scanline.

Initialise the top-left corner A[0,0] to zero. For all other elements of the matrix, evaluate them in order from upper left to lower right corner.

Step through the matrix and calculate
\[
A[i,j] = Minimum(A[i-1,j], A[i,j-1], A[i-1,j-1])  +  Difference(imageL, imageR)
\]
...where $Difference(imageL, imageR)$ is the difference between the i'th pixel of one image and the j'th pixel of the other.

Step 3: Once A has been filled, calculate a path of minimal cost through the matrix. In the simplest case, this is done by tracing back through the DP matrix starting at the bottom right corner A[n-1,n-1], and ending at A[0,0].

Choose the `path of least resistance', i.e. move up, left or up-left depending on $Minimum(A[i-1,j], A[i,j-1], A[i-1,j-1])$. Each time, fill in the disparity maps with your choice.

i.e.
DisparityMapL [i,y] = j-i
DisparityMapR [j,y] = i-j

Step 4: Once all this has been done for each scanline in the stereo pair, go through and map the lowest (possibly negative) disparity value to 0, and the highest disparity value to 255. This gives us our disparity map. Alternatively, the user can multiply by a fixed value.

...

That was the simplest case. In practise, we also have the options to:

(a) assign an additional bonus or penalty to moving diagonally in the dynamic programming matrix, depending on whether we want smooth or spiky (very disparate) images respectively,

(b) weight our choices for each scanline by those for the previous scanline, reducing error by `suggesting' ways to conform,

(c) run a median filter over the stereo images first to get rid of noise,

(d) not only run from bottom-right to top-left corner in the dynamic programming matrix, but also from top-left to bottom-right. We can choose the least-weight path overall. This helps reduce the cases where one of them goes horribly off the 'best' path because it followed the lowest-weight path into a dead end.

(e) improve running time by selecting a maximum disparity bound, b. The `path of least resistance' is never allowed to go outside this disparity bound because we set A[i,j] to a vast positive value if i > b or j > b.

%

One improvement we didn't implement: line skipping. (In that version, at thebeginning, every nâ€™th horizontal line is calculated to find bounding space for possible disparities in between.)
