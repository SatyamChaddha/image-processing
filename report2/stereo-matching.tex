% vim:ft=tex
% rubber: module xelatex

\subsection{Stereo matching}
\label{sec:stereo}

We followed the methods described in \cite{realtimestereo} to implement dynamic programming for stereo matching.


\begin{comment}
PSEUDOCODE:

A[i,j] = Minimum + Dif(ColorR,ColorL)
At the total beginning, A[0,0] has to be initialized with 0. Afterwards, all others elements are evaluated in the order from the upper left to the lower right corner.
It is absolutely necessary just to include already initialized matrix elements for performing the Min function inside the pseudocode above.
Once the matrix has been filled, a path of minimal cost can be calculated by tracing back through the DP matrix beginning from A[n-1,n-1], and ending in A[0,0] :
DisparityMapL [i,y] = j-i
DisparityMapR [j,y] = i-j
Up = A[i-1,j]
Left = A[i,j-1]
UpLeft = A[i-1,j-1]
Minimum = Min( Up,Left,UpLeft )
case Minimum of
UpLeft : i=i-1;j=j-1
Left : j=j-1
Up : i=i-1
end

For i = 0 to end,
For j = 0 to end,
...

Step 1: CALCULATE MATRIX
a1 = Right[i,y]
a2 = Left[j,y]
a3 = diff(a1,a2)
a4 = a3*scale + weight // denoise
a5 = f(a4, smooth[i,j])
b1 = A[i-1,j]
b2 = A[i,j-1]
b3 = A[i-1,j-1]
b4 = minimum(b1, b2, b3)
b5 = b4 - path[i,j] // Reusing paths
path[i,j] = path[i,j] * 0.875 // Reusing paths
A[i,j] = a5 + b5 // Write DP matrix

Step 2: FIND PATH
c1 = A[i-1,j]
c2 = A[i,j-1]
c3 = A[i-1,j-1]
c4 = minimum(c1, c2, c3)
c1 = c1 + weight1
c2 = c2 + weight2
c3 = c3 + weight3
// Choose new position
if (c4 <= c1) { j = j-1; i = i-1; } else
if (c4 <= c2) { j = j-1 } else
if (c4 <= c3) { i = i-1 }
// Remember paths
path[i,j] = constant
// Write disparity map
disparity[i,y] = j

One improvement we didn't implement: line skipping. (At first, every nâ€™th horizontal line is calculated to find bounding space for possible disparities in between.)

\end{comment}

